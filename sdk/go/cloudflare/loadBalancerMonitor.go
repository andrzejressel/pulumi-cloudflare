// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// If you're using Cloudflare's Load Balancing to load-balance across multiple origin servers or data centers, you configure one of these Monitors to actively check the availability of those servers over HTTP(S) or TCP.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-cloudflare/blob/master/website/docs/r/load_balancer_monitor.html.markdown.
type LoadBalancerMonitor struct {
	s *pulumi.ResourceState
}

// NewLoadBalancerMonitor registers a new resource with the given unique name, arguments, and options.
func NewLoadBalancerMonitor(ctx *pulumi.Context,
	name string, args *LoadBalancerMonitorArgs, opts ...pulumi.ResourceOpt) (*LoadBalancerMonitor, error) {
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["allowInsecure"] = nil
		inputs["description"] = nil
		inputs["expectedBody"] = nil
		inputs["expectedCodes"] = nil
		inputs["followRedirects"] = nil
		inputs["headers"] = nil
		inputs["interval"] = nil
		inputs["method"] = nil
		inputs["path"] = nil
		inputs["port"] = nil
		inputs["retries"] = nil
		inputs["timeout"] = nil
		inputs["type"] = nil
	} else {
		inputs["allowInsecure"] = args.AllowInsecure
		inputs["description"] = args.Description
		inputs["expectedBody"] = args.ExpectedBody
		inputs["expectedCodes"] = args.ExpectedCodes
		inputs["followRedirects"] = args.FollowRedirects
		inputs["headers"] = args.Headers
		inputs["interval"] = args.Interval
		inputs["method"] = args.Method
		inputs["path"] = args.Path
		inputs["port"] = args.Port
		inputs["retries"] = args.Retries
		inputs["timeout"] = args.Timeout
		inputs["type"] = args.Type
	}
	inputs["createdOn"] = nil
	inputs["modifiedOn"] = nil
	s, err := ctx.RegisterResource("cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &LoadBalancerMonitor{s: s}, nil
}

// GetLoadBalancerMonitor gets an existing LoadBalancerMonitor resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLoadBalancerMonitor(ctx *pulumi.Context,
	name string, id pulumi.ID, state *LoadBalancerMonitorState, opts ...pulumi.ResourceOpt) (*LoadBalancerMonitor, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["allowInsecure"] = state.AllowInsecure
		inputs["createdOn"] = state.CreatedOn
		inputs["description"] = state.Description
		inputs["expectedBody"] = state.ExpectedBody
		inputs["expectedCodes"] = state.ExpectedCodes
		inputs["followRedirects"] = state.FollowRedirects
		inputs["headers"] = state.Headers
		inputs["interval"] = state.Interval
		inputs["method"] = state.Method
		inputs["modifiedOn"] = state.ModifiedOn
		inputs["path"] = state.Path
		inputs["port"] = state.Port
		inputs["retries"] = state.Retries
		inputs["timeout"] = state.Timeout
		inputs["type"] = state.Type
	}
	s, err := ctx.ReadResource("cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &LoadBalancerMonitor{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *LoadBalancerMonitor) URN() pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *LoadBalancerMonitor) ID() pulumi.IDOutput {
	return r.s.ID()
}

// Do not validate the certificate when monitor use HTTPS. Only valid if `type` is "http" or "https".
func (r *LoadBalancerMonitor) AllowInsecure() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["allowInsecure"])
}

// The RFC3339 timestamp of when the load balancer monitor was created.
func (r *LoadBalancerMonitor) CreatedOn() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["createdOn"])
}

// Free text description.
func (r *LoadBalancerMonitor) Description() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["description"])
}

// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is "http" or "https". Default: "".
func (r *LoadBalancerMonitor) ExpectedBody() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["expectedBody"])
}

// The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is "http" or "https".
func (r *LoadBalancerMonitor) ExpectedCodes() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["expectedCodes"])
}

// Follow redirects if returned by the origin. Only valid if `type` is "http" or "https".
func (r *LoadBalancerMonitor) FollowRedirects() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["followRedirects"])
}

// The header name.
func (r *LoadBalancerMonitor) Headers() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["headers"])
}

// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.
func (r *LoadBalancerMonitor) Interval() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["interval"])
}

// The method to use for the health check. Valid values are any valid HTTP verb if `type` is "http" or "https", or `connectionEstablished` if `type` is "tcp". Default: "GET" if `type` is "http" or "https", or "connectionEstablished" if `type` is "tcp" .
func (r *LoadBalancerMonitor) Method() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["method"])
}

// The RFC3339 timestamp of when the load balancer monitor was last modified.
func (r *LoadBalancerMonitor) ModifiedOn() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["modifiedOn"])
}

// The endpoint path to health check against. Default: "/". Only valid if `type` is "http" or "https".
func (r *LoadBalancerMonitor) Path() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["path"])
}

func (r *LoadBalancerMonitor) Port() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["port"])
}

// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.
func (r *LoadBalancerMonitor) Retries() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["retries"])
}

// The timeout (in seconds) before marking the health check as failed. Default: 5.
func (r *LoadBalancerMonitor) Timeout() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["timeout"])
}

// The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'. Default: "http".
func (r *LoadBalancerMonitor) Type() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["type"])
}

// Input properties used for looking up and filtering LoadBalancerMonitor resources.
type LoadBalancerMonitorState struct {
	// Do not validate the certificate when monitor use HTTPS. Only valid if `type` is "http" or "https".
	AllowInsecure interface{}
	// The RFC3339 timestamp of when the load balancer monitor was created.
	CreatedOn interface{}
	// Free text description.
	Description interface{}
	// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is "http" or "https". Default: "".
	ExpectedBody interface{}
	// The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is "http" or "https".
	ExpectedCodes interface{}
	// Follow redirects if returned by the origin. Only valid if `type` is "http" or "https".
	FollowRedirects interface{}
	// The header name.
	Headers interface{}
	// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.
	Interval interface{}
	// The method to use for the health check. Valid values are any valid HTTP verb if `type` is "http" or "https", or `connectionEstablished` if `type` is "tcp". Default: "GET" if `type` is "http" or "https", or "connectionEstablished" if `type` is "tcp" .
	Method interface{}
	// The RFC3339 timestamp of when the load balancer monitor was last modified.
	ModifiedOn interface{}
	// The endpoint path to health check against. Default: "/". Only valid if `type` is "http" or "https".
	Path interface{}
	Port interface{}
	// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.
	Retries interface{}
	// The timeout (in seconds) before marking the health check as failed. Default: 5.
	Timeout interface{}
	// The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'. Default: "http".
	Type interface{}
}

// The set of arguments for constructing a LoadBalancerMonitor resource.
type LoadBalancerMonitorArgs struct {
	// Do not validate the certificate when monitor use HTTPS. Only valid if `type` is "http" or "https".
	AllowInsecure interface{}
	// Free text description.
	Description interface{}
	// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is "http" or "https". Default: "".
	ExpectedBody interface{}
	// The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is "http" or "https".
	ExpectedCodes interface{}
	// Follow redirects if returned by the origin. Only valid if `type` is "http" or "https".
	FollowRedirects interface{}
	// The header name.
	Headers interface{}
	// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Default: 60.
	Interval interface{}
	// The method to use for the health check. Valid values are any valid HTTP verb if `type` is "http" or "https", or `connectionEstablished` if `type` is "tcp". Default: "GET" if `type` is "http" or "https", or "connectionEstablished" if `type` is "tcp" .
	Method interface{}
	// The endpoint path to health check against. Default: "/". Only valid if `type` is "http" or "https".
	Path interface{}
	Port interface{}
	// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Default: 2.
	Retries interface{}
	// The timeout (in seconds) before marking the health check as failed. Default: 5.
	Timeout interface{}
	// The protocol to use for the healthcheck. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'. Default: "http".
	Type interface{}
}
